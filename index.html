<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<title>NEW YEAR GES</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
html,body{
  margin:0;
  overflow:hidden;
  background:#000;
  touch-action:none;
}
canvas{display:block}
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>

<script>
/* ================= DEVICE ================= */
const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

/* ================= SCENE ================= */
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  55,
  innerWidth/innerHeight,
  0.1,
  1000
);
camera.position.z = isMobile ? 42 : 32;

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setClearColor(0x000000);
document.body.appendChild(renderer.domElement);

/* ================= ROTATION CONTROL (FIX TOTAL) ================= */
let isDragging = false;
let lastX = 0;
let lastY = 0;

let targetRotX = 0;
let targetRotY = 0;
let currentRotX = 0;
let currentRotY = 0;

/* ===== MOUSE (PC) ===== */
addEventListener("mousedown", e=>{
  isDragging = true;
  lastX = e.clientX;
  lastY = e.clientY;
});

addEventListener("mouseup", ()=> isDragging = false);

addEventListener("mousemove", e=>{
  if(!isDragging) return;
  const dx = e.clientX - lastX;
  const dy = e.clientY - lastY;

  targetRotY += dx * 0.004;
  targetRotX += dy * 0.003;
  targetRotX = Math.max(-1.2, Math.min(1.2, targetRotX));

  lastX = e.clientX;
  lastY = e.clientY;
});

/* ===== TOUCH (ANDROID) ===== */
let pinchStart = 0;
let zoomStart = camera.position.z;

function dist(t1,t2){
  return Math.hypot(
    t1.clientX - t2.clientX,
    t1.clientY - t2.clientY
  );
}

addEventListener("touchstart", e=>{
  if(e.touches.length === 1){
    isDragging = true;
    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;
  }
  if(e.touches.length === 2){
    pinchStart = dist(e.touches[0], e.touches[1]);
    zoomStart = camera.position.z;
  }
},{passive:false});

addEventListener("touchmove", e=>{
  e.preventDefault();

  if(e.touches.length === 1 && isDragging){
    const dx = e.touches[0].clientX - lastX;
    const dy = e.touches[0].clientY - lastY;

    targetRotY += dx * 0.003;
    targetRotX += dy * 0.0025;
    targetRotX = Math.max(-1.2, Math.min(1.2, targetRotX));

    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;
  }

  if(e.touches.length === 2){
    const d = dist(e.touches[0], e.touches[1]);
    camera.position.z = zoomStart - (d - pinchStart) * 0.05;
    camera.position.z = Math.max(20, Math.min(60, camera.position.z));
  }
},{passive:false});

addEventListener("touchend", ()=> isDragging = false);

/* ================= PARTICLES ================= */
const COUNT = isMobile ? 5000 : 9000;
const geo = new THREE.BufferGeometry();
const pos = new Float32Array(COUNT * 3);

for(let i=0;i<pos.length;i++){
  pos[i] = (Math.random()-0.5) * 90;
}
geo.setAttribute("position", new THREE.BufferAttribute(pos,3));

const mat = new THREE.PointsMaterial({
  color:0xffb6c1,
  size:isMobile?0.22:0.26,
  transparent:true,
  blending:THREE.AdditiveBlending
});

scene.add(new THREE.Points(geo, mat));

/* ================= TEXT TO PARTICLES ================= */
function textToPoints(text){
  const c = document.createElement("canvas");
  c.width = isMobile ? 1400 : 2000;
  c.height = isMobile ? 700 : 900;
  const ctx = c.getContext("2d");

  ctx.clearRect(0,0,c.width,c.height);
  ctx.fillStyle="#fff";
  ctx.textAlign="center";
  ctx.textBaseline="middle";
  ctx.font=`900 ${isMobile?320:260}px Arial Black`;
  ctx.fillText(text,c.width/2,c.height/2);

  const data = ctx.getImageData(0,0,c.width,c.height).data;
  const pts=[];
  const scale = isMobile?10:14;

  for(let y=0;y<c.height;y+=6){
    for(let x=0;x<c.width;x+=6){
      if(data[(y*c.width+x)*4]>200){
        pts.push({
          x:(x-c.width/2)/scale,
          y:(c.height/2-y)/scale,
          z:0
        });
      }
    }
  }
  return pts;
}

/* ================= MORPH ================= */
function morph(text){
  const t = textToPoints(text);
  const p = geo.attributes.position.array;

  for(let i=0;i<COUNT;i++){
    const g = t[i % t.length];
    gsap.to(p,{
      [i*3]:g.x,
      [i*3+1]:g.y,
      [i*3+2]:g.z,
      duration:2,
      ease:"power4.inOut",
      onUpdate:()=>geo.attributes.position.needsUpdate=true
    });
  }
}

/* ================= EXPLODE ================= */
function explode(){
  const p = geo.attributes.position.array;
  for(let i=0;i<COUNT;i++){
    gsap.to(p,{
      [i*3]:p[i*3]+(Math.random()-0.5)*50,
      [i*3+1]:p[i*3+1]+(Math.random()-0.5)*50,
      [i*3+2]:p[i*3+2]+(Math.random()-0.5)*50,
      duration:1,
      onUpdate:()=>geo.attributes.position.needsUpdate=true
    });
  }
}

/* ================= TIMELINE ================= */
setTimeout(()=>morph("1"),1000);
setTimeout(explode,3000);
setTimeout(()=>morph("2"),3800);
setTimeout(explode,6000);
setTimeout(()=>morph("3"),6800);
setTimeout(explode,9000);
setTimeout(()=>morph("NEW YEAR GES"),10000);

/* ================= LOOP ================= */
function animate(){
  requestAnimationFrame(animate);

  /* SMOOTH ROTATION */
  currentRotX += (targetRotX - currentRotX) * 0.08;
  currentRotY += (targetRotY - currentRotY) * 0.08;

  scene.rotation.x = currentRotX;
  scene.rotation.y = currentRotY;

  renderer.render(scene,camera);
}
animate();

/* ================= RESIZE ================= */
addEventListener("resize",()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
